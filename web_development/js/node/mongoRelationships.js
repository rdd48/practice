// section 44
// blog post on designing a database structure: https://www.mongodb.com/blog/post/6-rules-of-thumb-for-mongodb-schema-design-part-3


// set up a random db
const mongoose = require('mongoose');
const { Schema } = mongoose

mongoose.connect('mongodb://localhost:27017/relationshipDemo', {
    useNewUrlParser: true
})
    .then(() => {
        console.log('connection open!')
    })
    .catch(err => {
        console.log(err)
    })

const userSchema = new Schema({
    first: String,
    last: String,
    address: [
        {
            // _id: {id: false},
            street: String,
            city: String,
            state: String,
            country: String,
        }
    ]
})

const User = mongoose.model('User', userSchema);

const makeUser = async () => {
    const u = new User({
        first: 'Teddy',
        last: 'Divine',
    })
    u.address.push({
        street: 'Clinton',
        city: 'Redwood',
        state: 'CA',
        country: 'USA'
    })
    const res = await u.save()
    console.log(res)
}

// makeUser(); // seed db

// one to few ? i.e., seems like all sub-data is included in one huge
const addAddress = async (id, addressObj) => {
    const user = await User.findById(id);
    user.address.push(addressObj)
    const res = await user.save()
    console.log(res)
}

// below user id was autogenerated
// addAddress('62081d2acf923ee6a29d52ce', { street: 'new', city: 'new', state: 'new', country: 'new' })

// one to many
// i.e., main table embeds references to other (child?) tables
const siteSchema = new Schema({
    name: String,
    users: [{
        type: Schema.Types.ObjectId,
        ref: 'User'
    }]
})

const Site = mongoose.model('Site', siteSchema);

const makeSite = async () => {
    const site = new Site({ name: 'mysite.com' });
    const teddy = await User.findOne({ first: 'Teddy' });
    site.users.push(teddy);
    await site.save();
}
// makeSite();

Site.findOne({ name: 'mysite.com' })
    .populate('users') // refers to the users obj with ref: 'User' attr in siteSchema
    .then(site => console.log(site))



// one to bajillions
// store reference to the parent in each child document

const tweetSchema = new Schema({
    text: String,
    user: {
        type: Schema.Types.ObjectId, ref: 'User'
    }
})

const Tweet = mongoose.model('Tweet', tweetSchema)

const makeTweets = async () => {
    const teddy = await User.findOne({ first: 'Teddy' });
    const tweet1 = new Tweet({
        text: 'feed me',
    })
    tweet1.user = teddy;
    tweet1.save();
}
makeTweets();

const populateTweet = async () => {
    Tweet.find({})
        .populate('user')
        // could .populate specific fields w/ more args, e.g.
        // .populate('user', 'first')
        .then(tweets => console.log(tweets))
}
populateTweet();